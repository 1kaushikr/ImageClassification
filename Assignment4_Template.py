# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VCbkADZbWed_ifAMwXi_E0SuH7dgz-fp
"""

from numpy.ma.core import shape
import numpy as np
from scipy import optimize
import pandas as pd
from matplotlib import pyplot as plt
class costing:
    def data_clean(self,data):
        data.dropna(inplace=True)
        y = np.array(data['label'])
        data = data.drop(['label'],axis=1)
        m,n = data.shape
        i=0 
        while i<n:
          if data.iloc[:,i].max()>0:
            data.iloc[:,i] = (data.iloc[:,i] - data.iloc[:,i].min())/(data.iloc[:,i].max()-data.iloc[:,i].min())
          i = i+ 1
        x = np.array(data)
        y = y.reshape((y.size,1))
        return x, y

    def sigmoid(self,z):
        if np.isscalar(z):
          z = 1/(1+np.exp(-z))
        if (z.ndim==1):
          for i in range(z.size):
            z[i] = 1/(1+np.exp(-z[i]))
        if(z.ndim==2):
          m ,k = z.shape
          for i in range(m):
            for j in range(k):
              z[i,j] = 1/(1+np.exp(-z[i,j]))
        return z
    

    def costFunctionReg(self,w,x,y,lambda_):
        w = np.reshape(w,(int(w.size/10),10), order='C')
        m,n = x.shape
        q = x@w
        h = self.sigmoid(q) 
        F = np.multiply(np.log(h),y)
        J1 = np.sum(F)
        G = np.multiply(np.log(1-h),1-y)
        J2 = np.sum(G)
        J3 = (lambda_/2)*np.sum(np.square(w[1:,:]))
        J = (-J1-J2+J3)/m   
        grad = x.T @ (h - y) + (lambda_*w)
        grad[0,:] = grad[0,:]   - w[0,:]
        return J, np.ravel(grad/y.size)
    

    def predictOneVsAll(self,w,x,num_labels):
        m, n = x.shape
        h = self.sigmoid(x @ w)
        s = np.nanargmax(h, axis=1).reshape((m,1))
        return s
        
    def minCostFun(self, data):
        x,Y = self.data_clean(data)
        m,n=x.shape
        x = np.concatenate((np.ones((m,1)),x),axis=1)
        w = np.zeros(10*n+10)
        y = np.zeros((m,10))
        for i in range(m):
          y[i,Y[i,0]]=1
        opt={'maxiter':4000}
        res = optimize.minimize(self.costFunctionReg,w,(x,y,0.1),method='TNC', jac=True,options=opt)
        w_ = res.x
        w_ = np.reshape(w_,(int(w_.size/10),10), order='C')
        a = self.predictOneVsAll(w_,x,10).reshape((m,1)) - Y
        q=0
        k=0
        for ele in a:
          if(ele==0):
            q+=1
          else:
            k+=1
        acr = np.around((q/m)*100,3)
        return np.around(w_,3),   acr

    def TestingAccu(self, test_data):
        x,Y = self.data_clean(data)
        m,n=x.shape
        x = np.concatenate((np.ones((m,1)),x),axis=1)
        a = self.predictOneVsAll(Wei,x,10).reshape((m,1)) - Y
        q=0
        k=0
        for ele in a:
          if(ele==0):
            q+=1
          else:
            k+=1
        acr = np.around((q/m)*100,3)
        return  acr

